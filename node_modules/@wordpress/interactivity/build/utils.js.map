{"version":3,"names":["_hooks","require","_signals","_hooks2","afterNextFrame","callback","Promise","resolve","done","clearTimeout","timeout","window","cancelAnimationFrame","raf","setTimeout","requestAnimationFrame","createFlusher","compute","notify","flush","dispose","effect","c","bind","x","useSignalEffect","_useEffect","eff","isExecuting","withScope","func","scope","getScope","ns","getNamespace","constructor","name","args","gen","value","it","setNamespace","setScope","next","resetNamespace","resetScope","e","throw","exports","useWatch","useInit","useEffect","inputs","useLayoutEffect","_useLayoutEffect","useCallback","_useCallback","useMemo","factory","_useMemo","createRootFragment","parent","replaceNode","concat","s","length","nextSibling","insert","r","insertBefore","__k","nodeType","parentNode","firstChild","childNodes","appendChild","removeChild"],"sources":["@wordpress/interactivity/src/utils.js"],"sourcesContent":["/**\n * External dependencies\n */\nimport {\n\tuseMemo as _useMemo,\n\tuseCallback as _useCallback,\n\tuseEffect as _useEffect,\n\tuseLayoutEffect as _useLayoutEffect,\n} from 'preact/hooks';\nimport { effect } from '@preact/signals';\n\n/**\n * Internal dependencies\n */\nimport {\n\tgetScope,\n\tsetScope,\n\tresetScope,\n\tgetNamespace,\n\tsetNamespace,\n\tresetNamespace,\n} from './hooks';\n\nconst afterNextFrame = ( callback ) => {\n\treturn new Promise( ( resolve ) => {\n\t\tconst done = () => {\n\t\t\tclearTimeout( timeout );\n\t\t\twindow.cancelAnimationFrame( raf );\n\t\t\tsetTimeout( () => {\n\t\t\t\tcallback();\n\t\t\t\tresolve();\n\t\t\t} );\n\t\t};\n\t\tconst timeout = setTimeout( done, 100 );\n\t\tconst raf = window.requestAnimationFrame( done );\n\t} );\n};\n\n// Using the mangled properties:\n// this.c: this._callback\n// this.x: this._compute\n// https://github.com/preactjs/signals/blob/main/mangle.json\nfunction createFlusher( compute, notify ) {\n\tlet flush;\n\tconst dispose = effect( function () {\n\t\tflush = this.c.bind( this );\n\t\tthis.x = compute;\n\t\tthis.c = notify;\n\t\treturn compute();\n\t} );\n\treturn { flush, dispose };\n}\n\n// Version of `useSignalEffect` with a `useEffect`-like execution. This hook\n// implementation comes from this PR, but we added short-cirtuiting to avoid\n// infinite loops: https://github.com/preactjs/signals/pull/290\nexport function useSignalEffect( callback ) {\n\t_useEffect( () => {\n\t\tlet eff = null;\n\t\tlet isExecuting = false;\n\t\tconst notify = async () => {\n\t\t\tif ( eff && ! isExecuting ) {\n\t\t\t\tisExecuting = true;\n\t\t\t\tawait afterNextFrame( eff.flush );\n\t\t\t\tisExecuting = false;\n\t\t\t}\n\t\t};\n\t\teff = createFlusher( callback, notify );\n\t\treturn eff.dispose;\n\t}, [] );\n}\n\n/**\n * Returns the passed function wrapped with the current scope so it is\n * accessible whenever the function runs. This is primarily to make the scope\n * available inside hook callbacks.\n *\n * @param {Function} func The passed function.\n * @return {Function} The wrapped function.\n */\nexport const withScope = ( func ) => {\n\tconst scope = getScope();\n\tconst ns = getNamespace();\n\tif ( func?.constructor?.name === 'GeneratorFunction' ) {\n\t\treturn async ( ...args ) => {\n\t\t\tconst gen = func( ...args );\n\t\t\tlet value;\n\t\t\tlet it;\n\t\t\twhile ( true ) {\n\t\t\t\tsetNamespace( ns );\n\t\t\t\tsetScope( scope );\n\t\t\t\ttry {\n\t\t\t\t\tit = gen.next( value );\n\t\t\t\t} finally {\n\t\t\t\t\tresetNamespace();\n\t\t\t\t\tresetScope();\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tvalue = await it.value;\n\t\t\t\t} catch ( e ) {\n\t\t\t\t\tgen.throw( e );\n\t\t\t\t}\n\t\t\t\tif ( it.done ) break;\n\t\t\t}\n\t\t\treturn value;\n\t\t};\n\t}\n\treturn ( ...args ) => {\n\t\tsetNamespace( ns );\n\t\tsetScope( scope );\n\t\ttry {\n\t\t\treturn func( ...args );\n\t\t} finally {\n\t\t\tresetNamespace();\n\t\t\tresetScope();\n\t\t}\n\t};\n};\n\n/**\n * Accepts a function that contains imperative code which runs whenever any of\n * the accessed _reactive_ properties (e.g., values from the global state or the\n * context) is modified.\n *\n * This hook makes the element's scope available so functions like\n * `getElement()` and `getContext()` can be used inside the passed callback.\n *\n * @param {Function} callback The hook callback.\n */\nexport function useWatch( callback ) {\n\tuseSignalEffect( withScope( callback ) );\n}\n\n/**\n * Accepts a function that contains imperative code which runs only after the\n * element's first render, mainly useful for intialization logic.\n *\n * This hook makes the element's scope available so functions like\n * `getElement()` and `getContext()` can be used inside the passed callback.\n *\n * @param {Function} callback The hook callback.\n */\nexport function useInit( callback ) {\n\t_useEffect( withScope( callback ), [] );\n}\n\n/**\n * Accepts a function that contains imperative, possibly effectful code. The\n * effects run after browser paint, without blocking it.\n *\n * This hook is equivalent to Preact's `useEffect` and makes the element's scope\n * available so functions like `getElement()` and `getContext()` can be used\n * inside the passed callback.\n *\n * @param {Function} callback Imperative function that can return a cleanup\n *                            function.\n * @param {any[]}    inputs   If present, effect will only activate if the\n *                            values in the list change (using `===`).\n */\nexport function useEffect( callback, inputs ) {\n\t_useEffect( withScope( callback ), inputs );\n}\n\n/**\n * Accepts a function that contains imperative, possibly effectful code. Use\n * this to read layout from the DOM and synchronously re-render.\n *\n * This hook is equivalent to Preact's `useLayoutEffect` and makes the element's\n * scope available so functions like `getElement()` and `getContext()` can be\n * used inside the passed callback.\n *\n * @param {Function} callback Imperative function that can return a cleanup\n *                            function.\n * @param {any[]}    inputs   If present, effect will only activate if the\n *                            values in the list change (using `===`).\n */\nexport function useLayoutEffect( callback, inputs ) {\n\t_useLayoutEffect( withScope( callback ), inputs );\n}\n\n/**\n * Returns a memoized version of the callback that only changes if one of the\n * inputs has changed (using `===`).\n *\n * This hook is equivalent to Preact's `useCallback` and makes the element's\n * scope available so functions like `getElement()` and `getContext()` can be\n * used inside the passed callback.\n *\n * @param {Function} callback Imperative function that can return a cleanup\n *                            function.\n * @param {any[]}    inputs   If present, effect will only activate if the\n *                            values in the list change (using `===`).\n */\nexport function useCallback( callback, inputs ) {\n\t_useCallback( withScope( callback ), inputs );\n}\n\n/**\n * Pass a factory function and an array of inputs. `useMemo` will only recompute\n * the memoized value when one of the inputs has changed.\n *\n * This hook is equivalent to Preact's `useMemo` and makes the element's scope\n * available so functions like `getElement()` and `getContext()` can be used\n * inside the passed factory function.\n *\n * @param {Function} factory Imperative function that can return a cleanup\n *                           function.\n * @param {any[]}    inputs  If present, effect will only activate if the\n *                           values in the list change (using `===`).\n */\nexport function useMemo( factory, inputs ) {\n\t_useMemo( withScope( factory ), inputs );\n}\n\n// For wrapperless hydration.\n// See https://gist.github.com/developit/f4c67a2ede71dc2fab7f357f39cff28c\nexport const createRootFragment = ( parent, replaceNode ) => {\n\treplaceNode = [].concat( replaceNode );\n\tconst s = replaceNode[ replaceNode.length - 1 ].nextSibling;\n\tfunction insert( c, r ) {\n\t\tparent.insertBefore( c, r || s );\n\t}\n\treturn ( parent.__k = {\n\t\tnodeType: 1,\n\t\tparentNode: parent,\n\t\tfirstChild: replaceNode[ 0 ],\n\t\tchildNodes: replaceNode,\n\t\tinsertBefore: insert,\n\t\tappendChild: insert,\n\t\tremoveChild( c ) {\n\t\t\tparent.removeChild( c );\n\t\t},\n\t} );\n};\n"],"mappings":"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"}